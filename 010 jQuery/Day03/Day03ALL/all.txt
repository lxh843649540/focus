今天学习的内容
1:复习总结昨天的重点 
2:作业
3:今天的内容
  3.1:jquery 遍历
	3.2:jquery 事件处理---* 重点&难点
#-----------------------------------
1:复习总结昨天的重点 
2:作业
3:今天的内容
  #jquery API
  样式:直接访问css样式属性
	#只访问一个单独css属性
	 $("..").css("属性名");
 	 获取计算后的样式
	 getComputedStyle(elem).css属性名
  #同时修改多个css属性
	 $("..").css({
	    css属性名:值,
			css属性名:值,
			...
	 });
   问题:不便于大项目维护
	 解决:大型项目中都要操作calss来代替换
	      单个样式.
  3.1:jquery 遍历节点.创建.添加.删除.替换. 复制
	  
		#遍历节点
		父子关系
    $("...").children('select'); 
		仅在直接(子)元素中查询
    $("..").find('selector');
		在所有(后代)元素中查询符合选择器元素
    $("..").parent()
		查询父元素
		$("..").parents('selector');
		查找祖先元素

		兄弟关系
    $("..").next()/prev("selector");
		要求必须紧领的前/后一个兄弟.
		如果有选择器，还必须满足选择器要求.
    $("..").siblings("selector");
		除自己之外的前后所有兄弟元素.
		如果有选择器，还要满足选择器的要求


    #创建.添加
    DOM添加新节点3步:
		 1:创建空元素
		 2:设置关键属性
		 3:将新元素添加到父元素最后子节点
    JQ创建元素2步
		 1:用html代码片段创建元素对象[jq对象]
		   var $elem = $("元素html代码片段");
			 仅在内存中
			 说明:如果html代码片段同时包含父元素
			 和子元素,$会同时创建父元素以及子元素
			 对象.
		 2:将新元素添加指定父元素下
		   $(parent).append($elem);在末尾追加
       $(parent).prepend($elem);在开头追加
			 $(child).before($elem); 在child之前插入
			 $(child).after($elem);  在child之后插入
     #删除节点
		   $(node).remove();删除节点


    

		 #替换. 复制
     替换
		  用后边，替换前边
			$("要替换的元素").replaceWith("新元素");
			用前边，替换后边
			$("新元素").replaceAll("要替换的元素");
     复制/克隆
		  浅克隆，只复制属性(id/class/)
			不复制行为(click/mouseover/...)
			var $clone = $("..").clone();
      深克隆,不但复制属性，而且复制行为
      var $clone = $("..").clone(true);



	3.2:jquery 事件处理---* 重点&难点
  鄙视题:jquery有几种事件绑定方式
	DOM:addEvenetlistener("事件名",fn);
	    removeEvenetListener("事件名",函数名);
    强调:要想移除事件监听，必须使用有名函数
		绑定事件监听，如果添加事件时使用匿名函数
		则不可能移除.

  1:绑定
	  $("..").bind("事件名",fn);       绑定
    $("..").unbind("事件名",函数名); 解除绑定
    $("..").unbind(); 移动该元素上所有事件绑定
	2:一次性绑定
	  $("..").one("事件名",fn);
    绑定事件，仅触发一次后自动触绑定
	3:常用事件绑定:简化
	  $("..").事件名(fn);
	  只对部分事件提供简化-->23个

  ##以上绑定方法,只能对当前页面上己存在
	  的元素添加事件绑定.
		动态生成元素无法自动绑定事件.

  解决1:利用冒泡:
	      将事件绑定己存在父元素一次
				function(e){
				  var  target = e.target;
					//target 触发事件:元素
				}
	解决2:
	4:事件代理
	$("parent").delegate("subselector","事件名",fn);
  fn-->this--->代替 e.target
  解除
	$("parent").undelegate("subselector","事件名");

  鄙视题:
	delegate vs bind
	1:事件监听个数:
	  delegate是仅在父元素添加一次事件监听
		bind通常都是是每个子元素都添加事件监听
  2:对动态添加的元素
	  delegate让动态添加元素自动响应指事件
		bind通常仅对现有元素添加绑定，
		无法自动给动态生成元素添加绑定

  #己废弃:
	 $("select").live("事件名",fn); 
	 $(document).delegate("select","事件",fn);
	 $("selector").die("事件名");

  #终极简化
	$("parent").on("事件名","selector",fn);

  #模拟操作:用代码模拟触发另一个元素的事件
	何时:如果少量平级平级元素拥有相同的事件处理
	     函数,不必利用冒泡，就模拟触发.
  如何:$("..").trigger("事件名");
	触发所有选中元素上的指定事件处理函数
  
  
  #---------------------------
	小结事件:
	jquery事件处理
	1:事件绑定
	  a:$("...").bind("事件名",fn);
		  $("...").bind("事件名1 事件名2 ",fn);
    b:事件对象
		  $("..").bind("事件名",function(e){
			  e==事件对象
				e.preventDefault();
			});
    c:绑定事件只执行一次
		  $("..").one("事件名",fn);
  2:$("...").unbind();
	  $("..").unbind("click");
  3:$("父元素").on("事件名","子元素",fn);


  
  #代码少<--> jquery 总结
  
  作业一:
	1:创建数组对象
	var list = [{"id":1001,"name":"tom"},
	 {"id":1002,"name":"jerry"},
	 {"id":1003,"name":"kk"}
	];
	2:依据数组创建对象jquery对象
	3:结果是一个表格
	最终结果如下
	-----------------------------
	|  雇员编号    |  雇员名称  |
	-----------------------------
	|  1001        |  tom       |
	-----------------------------
	|  1002        |  jerry     |
	-----------------------------
	|  1003        |  kk        |
	-----------------------------

